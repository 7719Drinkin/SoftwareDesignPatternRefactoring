# 项目分工方案

## 📌 项目概述

**目标**：一周内应用15+种设计模式重构Unity RPG游戏  
**最低要求**：6种模式（1个创建型 + 2个结构型 + 2个行为型 + 1个额外模式）  
**高分目标**：完成P0 + P1（15种模式）

---

## 🎯 优先级说明

- **P0（必须完成）**：最低要求的6种模式，必须完成
- **P1（高优先级）**：容易实现且影响大的模式，尽量完成
- **P2（可选）**：有时间再做的模式，提升分数

---

## 👥 成员任务分配

### 成员1：额外模式 + 架构模式

| 模式 | 优先级 | 时间 | 做什么 | 怎么做 | 涉及文件 |
|------|--------|------|--------|--------|---------|
| **访问者** | P0 | 1-2天 | 实现游戏对象访问接口 | 使用扩展方法，创建`Core/Visitor/` | `Utils/Extensions/EntityVisitorExtensions.cs` |
| **服务定位器** | P1 | 1天 | 统一管理所有Manager服务 | 创建`ServiceLocator`类 | `Core/DependencyInjection/ServiceLocator.cs` |
| **依赖注入** | P1 | 1-2天 | 解耦依赖关系 | 创建`DIContainer`和`PlayerFactory` | `Core/DependencyInjection/`<br>⚠️ 最后完成（Day 6） |
| **迭代器** | P2 | 0.5-1天 | 统一遍历接口 | 创建`IIterator`接口 | `Utils/Iterator/` |

**总计**：3.5-6天

---

### 成员2：创建型 + 结构型模式

| 模式 | 优先级 | 时间 | 做什么 | 怎么做 | 涉及文件 |
|------|--------|------|--------|--------|---------|
| **工厂方法** | P0 | 1-2天 | 统一创建敌人状态 | 创建`EnemyStateFactory`，只修改`Enemy.Awake()` | `Entity/Enemy/Factories/`<br>用`#region`标记 |
| **适配器** | P0 | 1-2天 | 统一技能接口 | 创建`ISkill`和`SkillAdapter`，只修改`SkillManager`注册 | `Skills/ISkill.cs`<br>`Skills/SkillAdapter.cs` |
| **抽象工厂** | P1 | 1天 | 统一创建敌人系统 | 基于工厂方法扩展 | `Entity/Enemy/Factories/` |
| **原型** | P1 | 0.5-1天 | 实现敌人克隆 | 实现`ICloneable`接口 | `Entity/Enemy/Prototype/`<br>`Enemy_Slime.cs` |
| **建造者** | P2 | 1天 | 链式构建技能配置 | 创建`SkillBuilder`类 | `Skills/Builders/` |

**总计**：4.5-7天

---

### 成员3：结构型 + 行为型模式

| 模式 | 优先级 | 时间 | 做什么 | 怎么做 | 涉及文件 |
|------|--------|------|--------|--------|---------|
| **装饰器** | P0 | 1-2天 | 动态组合技能效果 | 创建`Skills/Effects/`目录，尽量不修改现有技能类 | `Skills/Effects/IEffect.cs`<br>`Skills/Effects/CompositeEffect.cs` |
| **策略** | P0 | 1-2天 | 统一伤害计算策略 | 只修改`CharacterStats.DoDamage()`，用`#region`标记 | `Core/Damage/IDamageCalculationStrategy.cs`<br>`Stats/CharacterStats.cs` |
| **外观** | P1 | 1天 | 封装多个Manager系统 | 创建`GameFacade`类 | `Core/Facade/GameFacade.cs` |
| **模板方法** | P1 | 1-2天 | 统一状态基类 | 创建`BaseState.cs`，等成员2完成后 | `Entity/Enemy/States/BaseState.cs`<br>⚠️ 依赖成员2 |
| **组合** | P2 | 1天 | UI组件树结构 | 创建`UIComponent`抽象类 | `UI/Components/` |

**总计**：5-8天

---

### 成员4：行为型模式

| 模式 | 优先级 | 时间 | 做什么 | 怎么做 | 涉及文件 |
|------|--------|------|--------|--------|---------|
| **观察者** | P0 | 1-2天 | 事件通知系统 | 只添加事件发布代码，用`#region`标记，不修改现有逻辑 | `Core/Events/EventManager.cs`<br>各系统类方法末尾 |
| **命令** | P1 | 1-2天 | 封装输入操作 | 创建`PlayerInputHandler`类，不直接修改Player.Update | `Core/Commands/ICommand.cs`<br>`Player/PlayerInputHandler.cs` |
| **中介者** | P1 | 1天 | 统一UI组件通信 | 创建`UIMediator`类 | `UI/Mediator/UIMediator.cs` |
| **备忘录** | P2 | 1天 | 游戏状态保存/恢复 | 创建`GameMemento`类 | `Core/Memento/` |

**总计**：4-6天

---

### 成员5：架构模式 + 测试集成

| 模式 | 优先级 | 时间 | 做什么 | 怎么做 | 涉及文件 |
|------|--------|------|--------|--------|---------|
| **对象池** | P1 | 1-2天 | 复用游戏对象 | 创建通用`ObjectPool<T>`类 | `Core/ObjectPool/ObjectPool.cs` |
| **代理** | P1 | 1天 | 统一管理技能冷却和权限 | 创建`SkillProxy.cs`，不修改现有技能类 | `Skills/SkillProxy.cs` |
| **享元** | P2 | 0.5-1天 | 共享状态对象 | 创建`EnemyStateFlyweightFactory` | `Entity/Enemy/EnemyStateFlyweightFactory.cs` |
| **测试集成** | 必须 | 2-3天 | 测试所有模式，集成代码 | 测试、修复冲突、优化 | 全部模块 |

**总计**：4.5-7天

---

## 📅 一周时间安排

### Day 1（周一）
- **上午**：熟悉代码，确定重构点
- **下午**：创建Git分支，开始P0任务
  - 成员1：访问者模式
  - 成员2：工厂方法 + 适配器模式
  - 成员3：装饰器 + 策略模式
  - 成员4：观察者模式
  - 成员5：对象池模式

### Day 2-3（周二-周三）
- **并行开发P0任务**
- **完成P0后合并到develop**（参考冲突分析文档的合并顺序）

### Day 4（周四）
- **开始P1任务**
  - 成员1：服务定位器（依赖注入等Day 6）
  - 成员2：抽象工厂 + 原型模式
  - 成员3：外观模式（模板方法等成员2完成后）
  - 成员4：命令模式 + 中介者模式
  - 成员5：代理模式 + 开始测试

### Day 5（周五）
- **完成P1，开始P2（可选）**
  - 成员1：迭代器模式（可选）
  - 成员2：建造者模式（可选）
  - 成员3：模板方法（等成员2完成后）+ 组合模式（可选）
  - 成员4：备忘录模式（可选）
  - 成员5：享元模式（可选）+ 继续测试

### Day 6（周六）
- **最后合并与集成测试**
  - 成员1：完成依赖注入（最后合并，避免冲突）
  - 成员5：集成所有模式
  - 所有成员：修复问题，解决冲突

### Day 7（周日）
- **最终完善**：最终测试、代码审查、准备提交

---

## ✅ 完成目标

### 最低目标（必须完成 - P0）
- ✅ 6种模式：访问者、工厂方法、适配器、装饰器、策略、观察者
- ✅ 确保功能正常
- ✅ 代码标记完整

### 理想目标（P0 + P1）
- ✅ 15种模式：上述6种 + 服务定位器、依赖注入、抽象工厂、原型、外观、模板方法、命令、中介者、对象池、代理
- ✅ 全面解决架构问题

### 优秀目标（P0 + P1 + P2）
- ✅ 18+种模式：上述15种 + 迭代器、建造者、组合、备忘录、享元
- ✅ 获得高分

---

## 📋 任务检查清单

### P0 - 必须完成（6种模式）
- [ ] **成员1**：访问者模式
- [ ] **成员2**：工厂方法模式
- [ ] **成员2**：适配器模式
- [ ] **成员3**：装饰器模式
- [ ] **成员3**：策略模式
- [ ] **成员4**：观察者模式

### P1 - 高优先级（9种模式）
- [ ] **成员1**：服务定位器、依赖注入
- [ ] **成员2**：抽象工厂、原型
- [ ] **成员3**：外观、模板方法
- [ ] **成员4**：命令、中介者
- [ ] **成员5**：对象池、代理

### P2 - 可选（5种模式）
- [ ] **成员1**：迭代器
- [ ] **成员2**：建造者
- [ ] **成员3**：组合
- [ ] **成员4**：备忘录
- [ ] **成员5**：享元

### 测试与集成
- [ ] **成员5**：所有模式测试完成
- [ ] **成员5**：集成测试通过
- [ ] **成员5**：代码优化完成

---

## ⚠️ 冲突预防措施

### 核心原则
1. **优先创建新文件/新目录**：70%的模式通过创建新文件实现
2. **使用扩展方法/包装类**：避免直接修改共享类
3. **明确标记修改区域**：使用`#region`标记，避免误修改
4. **按顺序合并**：先合并独立的，后合并依赖的
5. **及时沟通**：修改共享类前先沟通

### 修改顺序（避免冲突）
1. **Day 2-3**：访问者、工厂方法、适配器、装饰器、策略、观察者
2. **Day 4**：抽象工厂、原型、外观、对象池、代理
3. **Day 5**：模板方法（等成员2完成）、命令、中介者
4. **Day 6**：依赖注入（最后合并）

### 共享类修改规则

| 类/目录 | 成员 | 修改方式 |
|---------|------|---------|
| `Player.cs` | 成员1（访问者） | 扩展方法或添加Accept方法（末尾） |
| | 成员1（依赖注入） | 最后修改，或使用工厂 |
| | 成员4（观察者） | 方法末尾添加事件发布 |
| | 成员4（命令） | 创建PlayerInputHandler，不修改Update |
| `Enemy.cs` | 成员1（访问者） | 扩展方法或添加Accept方法（末尾） |
| | 成员2（工厂方法） | 只修改Awake方法，标记区域 |
| | 成员4（观察者） | 方法末尾添加事件发布 |
| `Skills/` | 成员2（适配器） | 创建新文件ISkill.cs、SkillAdapter.cs |
| | 成员3（装饰器） | 创建新目录Effects/ |
| | 成员5（代理） | 创建新文件SkillProxy.cs |
| `PlayerState.cs`<br>`EnemyState.cs` | 成员2（工厂方法） | 先完成，只修改创建逻辑 |
| | 成员3（模板方法） | 后完成，基于成员2的代码 |

---

## 📝 代码标记规范

所有重构代码必须添加标记：
```csharp
// ========== Refactored with XXX Pattern ==========
// 优先级：P0/P1/P2
// 重构人员：成员X
// 修改区域：[具体方法名或区域]
// 注意：此区域由成员X负责，其他成员请勿修改
// ============================================================

#region Factory Method Pattern - Member2
// 成员2的修改区域
#endregion
```

---

## 🔗 相关文档

- **详细冲突分析与解决方案**：`doc/冲突分析与解决方案.md`
- **详细重构方案**：`doc/重构方案.md`

---
