# 源码类说明文档

本文档介绍Unity RPG游戏源码中的主要类，包括类的作用、关联关系、设计缺点和重构方案。

---

## 📋 目录

1. [核心实体类](#核心实体类)
2. [状态机系统](#状态机系统)
3. [技能系统](#技能系统)
4. [属性系统](#属性系统)
5. [物品系统](#物品系统)
6. [管理器系统](#管理器系统)
7. [UI系统](#ui系统)
8. [存档系统](#存档系统)

---

## 核心实体类

### Entity.cs
**作用**：所有游戏实体的基类，提供通用的物理交互、碰撞检测、击退效果和翻转功能。

**重要关联**：
- 被`Player`和`Enemy`继承
- 包含`CharacterStats`、`EntityFX`、`Animator`、`Rigidbody2D`等组件
- 提供地面检测、墙壁检测、攻击检测等通用方法

**设计缺点**：
1. ❌ 缺乏访问者模式支持，无法统一访问不同类型的实体
2. ❌ 翻转逻辑与实体耦合，难以扩展
3. ❌ 击退效果硬编码，无法灵活配置

**重构方案**：
- ✅ **访问者模式**：添加`Accept(IGameObjectVisitor visitor)`方法，支持统一访问
- ✅ **策略模式**：将击退逻辑提取为策略，支持不同击退效果
- ✅ **扩展方法**：使用扩展方法添加访问者支持，避免直接修改基类

---

### Player.cs
**作用**：玩家控制器，管理玩家的状态机、技能系统、装备系统和输入处理。

**重要关联**：
- 继承自`Entity`
- 包含`PlayerStateMachine`和15+个状态对象
- 依赖`SkillManager.instance`（单例）
- 依赖`PlayerManager.instance.player`（单例）
- 与`Inventory`、`CharacterStats`、`UI_InGame`紧密耦合

**设计缺点**：
1. ❌ **单例依赖严重**：直接使用`SkillManager.instance`、`PlayerManager.instance`
2. ❌ **状态创建重复**：在`Awake()`中手动创建所有状态对象
3. ❌ **输入处理分散**：输入逻辑分散在各个状态中
4. ❌ **紧耦合**：直接依赖多个Manager单例，难以测试
5. ❌ **缺乏事件通知**：状态变化、伤害等事件没有统一通知机制

**重构方案**：
- ✅ **依赖注入**：通过构造函数注入依赖，替代单例访问
- ✅ **工厂方法模式**：使用`PlayerStateFactory`统一创建状态
- ✅ **命令模式**：创建`PlayerInputHandler`封装输入处理
- ✅ **观察者模式**：添加事件发布，通知UI和其他系统
- ✅ **访问者模式**：添加`Accept`方法支持统一访问

---

### Enemy.cs
**作用**：敌人基类，实现敌人的AI行为、状态机、攻击系统和奖励机制。

**重要关联**：
- 继承自`Entity`
- 包含`EnemyStateMachine`和状态对象
- 依赖`DroppedItemManager.instance`（单例）
- 与`EnemyStats`、`ItemDrop`、`ExperienceDrop`关联

**设计缺点**：
1. ❌ **状态创建重复**：每个敌人子类（Skeleton、NightBorn、Slime）都要重复创建状态
2. ❌ **缺乏工厂抽象**：状态创建逻辑分散，难以统一管理
3. ❌ **单例依赖**：直接使用`DroppedItemManager.instance`
4. ❌ **缺乏事件通知**：敌人死亡、受伤等事件没有通知机制

**重构方案**：
- ✅ **工厂方法模式**：创建`EnemyStateFactory`抽象工厂，统一创建状态
- ✅ **抽象工厂模式**：创建`EnemySystemFactory`统一创建敌人系统
- ✅ **原型模式**：为`Enemy_Slime`实现克隆接口，支持分裂机制
- ✅ **观察者模式**：添加事件发布，通知UI和奖励系统
- ✅ **访问者模式**：添加`Accept`方法支持统一访问

---

## 状态机系统

### PlayerState.cs
**作用**：玩家状态基类，定义状态的基本结构和生命周期方法。

**重要关联**：
- 被所有玩家状态类继承（IdleState、MoveState、AttackState等）
- 与`PlayerStateMachine`配合使用
- 包含`Player`和`PlayerStateMachine`引用

**设计缺点**：
1. ❌ **缺乏模板方法**：状态的生命周期方法没有统一的模板
2. ❌ **代码重复**：Enter、Exit、Update等方法在子类中重复实现
3. ❌ **输入处理分散**：每个状态都要处理输入，代码重复

**重构方案**：
- ✅ **模板方法模式**：创建`BaseState`抽象类，定义模板方法
- ✅ **命令模式**：统一输入处理，减少状态类中的输入代码

---

### EnemyState.cs
**作用**：敌人状态基类，定义敌人状态的基本结构。

**重要关联**：
- 被所有敌人状态类继承（SkeletonMoveState、NightBornAttackState等）
- 与`EnemyStateMachine`配合使用

**设计缺点**：
1. ❌ **与PlayerState重复**：两个状态基类结构相似，代码重复
2. ❌ **缺乏模板方法**：状态逻辑没有统一的模板
3. ❌ **状态创建分散**：每个敌人类型都要手动创建状态

**重构方案**：
- ✅ **模板方法模式**：创建统一的`BaseState`抽象类
- ✅ **工厂方法模式**：使用工厂统一创建状态，减少重复代码

---

### PlayerStateMachine.cs / EnemyStateMachine.cs
**作用**：状态机类，管理状态的切换和生命周期。

**重要关联**：
- 管理`PlayerState`或`EnemyState`的切换
- 被`Player`和`Enemy`使用

**设计缺点**：
1. ❌ **代码重复**：两个状态机类结构完全相同
2. ❌ **缺乏泛型支持**：无法统一管理不同类型的状态

**重构方案**：
- ✅ **泛型重构**：创建泛型`StateMachine<TState>`统一管理
- ✅ **模板方法模式**：统一状态切换逻辑

---

## 技能系统

### Skill.cs
**作用**：技能基类，提供通用的技能冷却、使用检测和敌人查找功能。

**重要关联**：
- 被所有技能类继承（Dash_Skill、Sword_Skill、Blackhole_Skill等）
- 依赖`PlayerManager.instance.player`（单例）
- 提供`FindClosetEnemy`等通用方法

**设计缺点**：
1. ❌ **缺乏统一接口**：技能类没有统一的接口，难以统一管理
2. ❌ **单例依赖**：直接使用`PlayerManager.instance`
3. ❌ **效果系统分散**：技能效果逻辑分散在各个技能类中
4. ❌ **缺乏装饰支持**：无法动态组合技能效果

**重构方案**：
- ✅ **适配器模式**：创建`ISkill`接口，统一技能接口
- ✅ **装饰器模式**：创建`IEffect`接口和`CompositeEffect`，支持效果组合
- ✅ **代理模式**：创建`SkillProxy`统一管理技能冷却和权限
- ✅ **依赖注入**：通过构造函数注入Player，替代单例

---

### SkillManager.cs
**作用**：技能管理器，作为技能系统的中央管理器，统一管理各种技能组件。

**重要关联**：
- 单例模式，被`Player`、`UI_InGame`等类使用
- 管理8种技能组件（dash、clone、sword、blackhole等）

**设计缺点**：
1. ❌ **单例滥用**：全局单例导致紧耦合
2. ❌ **硬编码技能**：技能列表硬编码，难以扩展
3. ❌ **缺乏接口抽象**：直接管理具体技能类，缺乏抽象

**重构方案**：
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例
- ✅ **适配器模式**：通过`ISkill`接口统一管理技能
- ✅ **依赖注入**：通过DI容器管理技能依赖

---

## 属性系统

### CharacterStats.cs
**作用**：角色属性系统，管理角色的所有属性和状态效果，包含基础属性、伤害计算、元素效果和状态异常。

**重要关联**：
- 被`PlayerStats`和`EnemyStats`继承
- 包含各种`Stat`对象（strength、agility、damage等）
- 处理伤害计算、状态效果（点燃、冰冻、电击）

**设计缺点**：
1. ❌ **伤害计算分散**：`DoDamage()`方法包含大量if-else，难以扩展
2. ❌ **缺乏策略抽象**：不同伤害类型（物理、魔法、元素）没有统一策略
3. ❌ **状态效果硬编码**：状态效果逻辑硬编码，难以扩展
4. ❌ **缺乏事件通知**：属性变化、状态效果没有事件通知

**重构方案**：
- ✅ **策略模式**：创建`IDamageCalculationStrategy`接口，提取伤害计算策略
- ✅ **装饰器模式**：使用装饰器模式组合状态效果
- ✅ **观察者模式**：添加事件发布，通知UI属性变化

---

### Stat.cs
**作用**：属性值类，管理单个属性的基础值、修改器和最终值。

**重要关联**：
- 被`CharacterStats`使用
- 支持添加/移除修改器

**设计缺点**：
1. ❌ **缺乏事件通知**：属性值变化没有通知机制

**重构方案**：
- ✅ **观察者模式**：添加属性变化事件

---

## 物品系统

### ItemData.cs
**作用**：物品数据基类（ScriptableObject），定义物品的基本信息。

**重要关联**：
- 被`ItemData_Equipment`继承
- 被`Inventory`、`ItemDrop`使用

**设计缺点**：
1. ❌ **效果系统分散**：物品效果逻辑分散在各个Effect类中
2. ❌ **缺乏统一接口**：物品效果没有统一接口

**重构方案**：
- ✅ **装饰器模式**：创建`IEffect`接口，统一物品效果
- ✅ **策略模式**：将物品效果提取为策略

---

### Inventory.cs
**作用**：物品栏系统，管理玩家的装备、背包和仓库，实现物品的装备、使用、合成和存档功能。

**重要关联**：
- 单例模式，被`UI_InGame`、`Player`等使用
- 管理`ItemData`、`InventoryItem`
- 实现`ISaveManager`接口

**设计缺点**：
1. ❌ **单例滥用**：全局单例导致紧耦合
2. ❌ **事件系统分散**：装备、使用事件分散，缺乏统一管理
3. ❌ **UI耦合**：直接管理UI槽位，与UI系统紧耦合

**重构方案**：
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例
- ✅ **观察者模式**：统一事件通知机制
- ✅ **中介者模式**：使用`UIMediator`解耦UI系统

---

## 管理器系统

### GameManager.cs
**作用**：游戏管理器，管理游戏的核心功能，负责检查点系统、场景重启、游戏暂停和存档管理。

**重要关联**：
- 单例模式
- 管理`CheckPoint`、`Chest`
- 依赖`SaveManager.instance`、`PlayerManager.instance`
- 实现`ISaveManager`接口

**设计缺点**：
1. ❌ **单例滥用**：全局单例
2. ❌ **职责过多**：管理检查点、宝箱、暂停等多个职责
3. ❌ **紧耦合**：直接依赖多个Manager单例

**重构方案**：
- ✅ **外观模式**：创建`GameFacade`封装多个Manager系统
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例
- ✅ **依赖注入**：通过DI容器管理依赖

---

### PlayerManager.cs
**作用**：玩家管理器，管理玩家的核心数据（货币、经验值、等级系统）和存档管理。

**重要关联**：
- 单例模式
- 管理`Player`对象
- 依赖`AudioManager.instance`、`Inventory.instance`
- 实现`ISaveManager`接口

**设计缺点**：
1. ❌ **单例滥用**：全局单例
2. ❌ **紧耦合**：直接依赖多个Manager单例
3. ❌ **缺乏事件通知**：经验、等级变化没有事件通知

**重构方案**：
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例
- ✅ **观察者模式**：添加经验、等级变化事件
- ✅ **依赖注入**：通过DI容器管理依赖

---

### AudioManager.cs
**作用**：音频管理器，管理音效和背景音乐。

**重要关联**：
- 单例模式
- 被多个类使用（PlayerManager、GameManager等）

**设计缺点**：
1. ❌ **单例滥用**：全局单例

**重构方案**：
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例

---

### DroppedItemManager.cs
**作用**：掉落物品管理器，管理掉落物品和经验球的生成。

**重要关联**：
- 单例模式
- 管理`ItemObject`、`ExperienceObject`
- 实现`ISaveManager`接口

**设计缺点**：
1. ❌ **单例滥用**：全局单例
2. ❌ **对象池缺失**：频繁创建/销毁对象，性能问题
3. ❌ **硬编码预制体**：预制体硬编码，难以扩展

**重构方案**：
- ✅ **对象池模式**：使用对象池复用物品和经验球
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例

---

### AfterImageManager.cs
**作用**：残影管理器，管理玩家冲刺时的残影效果。

**重要关联**：
- 单例模式
- 被`PlayerDashState`使用

**设计缺点**：
1. ❌ **单例滥用**：全局单例
2. ❌ **对象池缺失**：频繁创建/销毁残影对象

**重构方案**：
- ✅ **对象池模式**：使用对象池复用残影对象
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例

---

## UI系统

### UI.cs
**作用**：主UI控制器，管理不同UI面板的切换和工具提示。

**重要关联**：
- 管理`UI_InGame`、`UI_MainMenu`等UI面板
- 管理多个ToolTip（`UI_ItemToolTip`、`UI_StatToolTip`等）
- 依赖`AudioManager.instance`、`GameManager.instance`

**设计缺点**：
1. ❌ **单例依赖**：直接使用多个Manager单例
2. ❌ **UI组件分散**：UI组件之间缺乏统一通信机制
3. ❌ **职责过多**：管理多个UI面板和工具提示

**重构方案**：
- ✅ **中介者模式**：创建`UIMediator`统一管理UI组件通信
- ✅ **组合模式**：创建UI组件树结构，统一管理
- ✅ **观察者模式**：使用事件系统解耦UI更新

---

### UI_InGame.cs
**作用**：游戏内UI管理器，管理所有游戏内UI元素的显示和更新（生命值、经验值、货币、技能冷却等）。

**重要关联**：
- 依赖`SkillManager.instance`、`Inventory.instance`、`PlayerManager.instance`
- 管理多个技能图标和装备图标
- 直接绑定技能事件

**设计缺点**：
1. ❌ **单例依赖严重**：直接使用多个Manager单例
2. ❌ **紧耦合**：直接依赖技能、物品栏等系统
3. ❌ **事件绑定分散**：事件绑定代码分散，难以维护
4. ❌ **缺乏统一更新机制**：UI更新逻辑分散

**重构方案**：
- ✅ **观察者模式**：通过事件系统更新UI，解耦依赖
- ✅ **中介者模式**：使用`UIMediator`统一管理UI更新
- ✅ **服务定位器模式**：使用`ServiceLocator`替代单例访问

---

## 存档系统

### SaveManager.cs
**作用**：存档管理器，管理游戏的保存和加载功能，统一管理所有实现了`ISaveManager`接口的组件。

**重要关联**：
- 单例模式
- 管理`ISaveManager`列表（GameManager、PlayerManager、Inventory等）
- 使用`FileDataHandler`处理文件操作

**设计缺点**：
1. ❌ **单例滥用**：全局单例
2. ❌ **查找机制低效**：使用`FindAllSaveManagers()`查找，性能问题

**重构方案**：
- ✅ **服务定位器模式**：使用`ServiceLocator`统一管理
- ✅ **注册机制**：使用注册机制替代查找机制

---

### ISaveManager.cs
**作用**：存档接口，定义保存和加载数据的方法。

**重要关联**：
- 被`GameManager`、`PlayerManager`、`Inventory`等实现
- 被`SaveManager`统一管理

**设计缺点**：
1. ✅ 接口设计合理，无需重构

**重构方案**：
- ✅ 保持现有设计

---

## 📊 重构模式总结

| 类名 | 主要设计缺点 | 重构使用的模式 |
|------|------------|--------------|
| **Entity** | 缺乏访问者支持 | 访问者模式（扩展方法） |
| **Player** | 单例依赖、状态创建重复、输入分散 | 依赖注入、工厂方法、命令模式、观察者模式、访问者模式 |
| **Enemy** | 状态创建重复、单例依赖 | 工厂方法、抽象工厂、原型模式、观察者模式、访问者模式 |
| **PlayerState/EnemyState** | 代码重复、缺乏模板 | 模板方法模式 |
| **Skill** | 缺乏统一接口、单例依赖、效果分散 | 适配器模式、装饰器模式、代理模式、依赖注入 |
| **SkillManager** | 单例滥用、硬编码技能 | 服务定位器、适配器模式、依赖注入 |
| **CharacterStats** | 伤害计算分散、缺乏策略 | 策略模式、装饰器模式、观察者模式 |
| **Inventory** | 单例滥用、UI耦合 | 服务定位器、观察者模式、中介者模式 |
| **GameManager** | 单例滥用、职责过多 | 外观模式、服务定位器、依赖注入 |
| **PlayerManager** | 单例滥用、紧耦合 | 服务定位器、观察者模式、依赖注入 |
| **AudioManager** | 单例滥用 | 服务定位器 |
| **DroppedItemManager** | 单例滥用、对象池缺失 | 对象池模式、服务定位器 |
| **AfterImageManager** | 单例滥用、对象池缺失 | 对象池模式、服务定位器 |
| **UI.cs** | 单例依赖、UI分散 | 中介者模式、组合模式、观察者模式 |
| **UI_InGame** | 单例依赖严重、紧耦合 | 观察者模式、中介者模式、服务定位器 |
| **SaveManager** | 单例滥用、查找低效 | 服务定位器、注册机制 |

---

## 📝 说明

1. **状态类省略**：具体的状态类（如`PlayerIdleState`、`SkeletonMoveState`等）结构相似，已省略详细说明，只介绍基类。
2. **技能类省略**：具体的技能类（如`Dash_Skill`、`Sword_Skill`等）继承自`Skill`，已省略详细说明。
3. **UI组件省略**：具体的UI组件类（如`UI_ItemSlot`、`UI_HealthBar`等）功能单一，已省略详细说明。
4. **Effect类省略**：物品效果类（如`Fire_Effect`、`Heal_Effect`等）结构相似，已省略详细说明。

---

**详细重构方案请参考**：`doc/重构方案.md`  
**任务分配请参考**：`doc/分工方案.md`
